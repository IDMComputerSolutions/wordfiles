<?xml version="1.0"?>
<Templates encode="utf8escenc"><Template Name="auto" Comments="0" Strings="0">auto [+var+] = [+value+];</Template><Template Name="bool">bool [+var+] = [+false+];</Template><Template Name="char">char [+var+][] = "[+value+]";</Template><Template Name="class">class [+className+] {&#xD;
	^&#xD;
};</Template><Template Name="const_cast">const_cast&lt;[+newtype+]&gt;([+expression+])</Template><Template Name="delete">delete [+var+];</Template><Template Name="do">do&#xD;
{&#xD;
	^&#xD;
}&#xD;
while([+evaluation+]);</Template><Template Name="dynamic_cast">dynamic_cast&lt;[+newtype+]&gt;([+expression+])</Template><Template Name="else">else &#xD;
{&#xD;
	^&#xD;
}</Template><Template Name="elseif">else if ([+evaluation+])&#xD;
{&#xD;
	^&#xD;
}</Template><Template Name="enum">enum [+name+] { [+values+] } [+objects+];</Template><Template Name="explicit">explicit [+className+]([+params+]);</Template><Template Name="extern">extern [+strliteral+] [+declaration+];</Template><Template Name="float">float [+var+] = [+number+];</Template><Template Name="for">for (int [+n+]=[+X+]; [+n+]&lt;[+Y+]; [+n+]++)&#xD;
{&#xD;
	^&#xD;
}</Template><Template Name="friend">friend [+className+];</Template><Template Name="function">[+type+] [+name+] ([+parameters+])&#xD;
{&#xD;
	^&#xD;
}</Template><Template Name="if" Comments="0" Strings="0">if ([+evaluation+]) &#xD;
{&#xD;
	^&#xD;
}</Template><Template Name="include">#include "[+filename+]"</Template><Template Name="inline">inline [+type+] [+name+] ([+params+])&#xD;
{&#xD;
	^&#xD;
}</Template><Template Name="int">int [+var+] = [+integer+];</Template><Template Name="mutable">mutable [+type+] [+var+];</Template><Template Name="namespace">namespace [+nsName+]&#xD;
{&#xD;
	^&#xD;
}</Template><Template Name="operator">operator[+symbol+]([+params+]);</Template><Template Name="private">private:&#xD;
	[+members+];</Template><Template Name="protected">protected:&#xD;
	[+members+];</Template><Template Name="public">public:&#xD;
	[+members+];</Template><Template Name="reinterpret_cast">reinterpret_cast&lt;[+newtype+]&gt;([+expression+])</Template><Template Name="sizeof">sizeof([+char+])</Template><Template Name="static">static [+int+] [+n+]=[+val+]; </Template><Template Name="static_cast">static_cast&lt;[+newtype+]&gt;([+expression+])</Template><Template Name="struct">struct [+name+]&#xD;
{&#xD;
	[+memtype+] [+memname+];&#xD;
	^&#xD;
} [+object names+];</Template><Template Name="switch">switch ([+expression+])&#xD;
{&#xD;
	case [+value+]:&#xD;
		^ &#xD;
	break;&#xD;
	default:&#xD;
		&#xD;
}</Template><Template Name="template">template&lt;[+paramslist+]&gt; [+declaration+]</Template><Template Name="this">this-&gt;[+member+]</Template><Template Name="try">try&#xD;
{&#xD;
	^ // code to try&#xD;
}&#xD;
catch ([+type+] [+e+])&#xD;
{&#xD;
	// error handling&#xD;
}</Template><Template Name="typedef">typedef [+type+] [+identifier+];</Template><Template Name="typeid">typeid([+type+])</Template><Template Name="typename">typename [+identifier+]</Template><Template Name="union">union [+tag+]&#xD;
{&#xD;
	[+memtype+] [+memname+];&#xD;
	^&#xD;
} [+objects+];&#xD;
</Template><Template Name="using">using namespace [+nsName+];</Template><Template Name="uuid">uuid("[+guid+]")</Template><Template Name="virtual">virtual [+type+] [+name+];</Template><Template Name="void">void [+function+] ([+params+])&#xD;
{&#xD;
	^&#xD;
}</Template><Template Name="volatile">volatile [+type+] [+var+];</Template><Template Name="whcar_t">wchar_t [+name+] = [+value+];</Template><Template Name="while">while ([+evaluation+]) {&#xD;
	^ &#xD;
}</Template></Templates>
